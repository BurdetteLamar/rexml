
= \REXML Tutorial

== Preliminaries

All examples here assume that the following code has been executed:

  require 'rexml/document'

The source XML for many examples here is from file
{books.xml}[https://www.w3schools.com/xml/books.xml] at w3schools.com.
You may find it convenient to open that page in a new tab
(Ctrl-click in some browsers).

For convenience, we capture the XML into a string variable:

  require 'open-uri'
  source_string = URI.open('https://www.w3schools.com/xml/books.xml').read

And into a file:

  File.write('source_file.xml', source_string)

== Parsing \XML \Source

Use method REXML::Document.new to parse XML source.

The source may be a string:

  doc = REXML::Document.new(source_string)

Or an \IO stream:

  doc = File.open('source_file.xml', 'r') do |io|
    REXML::Document.new(io)
  end

Method <tt>URI.open</tt> returns a StringIO object,
so the source can be from a web page:

  require 'open-uri'
  io = URI.open("https://www.w3schools.com/xml/books.xml")
  io.class # => StringIO
  doc = REXML::Document.new(io)

For any of these sources, the returned object is an REXML::Document:

  doc.class # => REXML::Document

== Exploring the Document

An REXML::Document object represents an XML document.

A document inherits from its ancestor classes:

- REXML::Child (includes module REXML::Node)
  - REXML::Parent (includes module {Enumerable}[rdoc-ref:Enumerable]).
    - REXML::Element (includes module REXML::Namespace).
      - REXML::Document

This section covers only properties unique to a document
(that is, not inherited or included).

[Root Element]

  A document may have a single element child, called the _root_ _element_,
  that may be retrieved with method +root+:

    doc.root # => <bookstore> ... </>
    doc.root.class # => REXML::Element

    REXML::Document.new('').root # => nil

[XML Declaration]

  A document has an XML declaration:

    doc.xml_decl # => <?xml ... ?>
    doc.xml_decl.class # => REXML::XMLDecl

    REXML::Document.new('').xml_decl # => <?xml ... ?>

    other_xml_source = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>"'
    other_doc = REXML::Document.new(other_xml_source)
    xml_decl = other_doc.xml_decl
    xml_decl.to_s  # => "<?xml version='1.0' encoding='UTF-8' standalone="yes"?>"

  The version, encoding, and stand-alone values may be retrieved separately:

    other_doc.version      # => "1.0"
    other_doc.encoding     # => "UTF-8"
    other_doc.stand_alone? # => "yes"

[Document Type]

  A document may have a document type:

    doc.doctype # => nil

    doc_type = REXML::Document.new('<!DOCTYPE foo>').doctype
    doc_type.class # => REXML::DocType
    doc_type.to_s  # => "<!DOCTYPE foo>"
    doc.doc_type   # => nil

[Node Type]

  A document also has a node type (always +:document+):

    doc.node_type # => :document

[Name]

  A document has a name (always an empty string):

    doc.name # => ""

[Document]

  \Method REXML::Document#document returns +self+:

    doc.document == doc # => true

  An object of a different class (\REXML::Element or \REXML::Child)
  may have a document, which is the document to which the object belongs;
  if so, that document will be an \REXML::Document object.

    doc.root.document.class # => REXML::Document

=== The Document's Node Tree

Thg nodes in a document form a tree, descending from the root element:

  root_ele.children.each do |child|
    p [child, child.class]
  end

Output:

  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='cooking'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='children'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web' cover='paperback'> ... </>]
  [REXML::Text, "\n\n"]

Element nodes in the document may be accessed separately:

  root_ele.elements.each do |element|
    p [element.class, element]
  end

Output:

  [REXML::Element, <book category='cooking'> ... </>]
  [REXML::Element, <book category='children'> ... </>]
  [REXML::Element, <book category='web'> ... </>]
  [REXML::Element, <book category='web' cover='paperback'> ... </>]

Note that while in this example, all the children of the root element are
elements of the same name, <tt>'book'</tt>, that is not true of all documents;
a root element (or any other element) may have any mixture of child elements.

Note also that the document is itself an element:

  doc.kind_of?(REXML::Element) # => true

because the parent class of \REXML::Document is \REXML::Element.

== Exploring Elements

An REXML::Element object represents an XML element.

::new
#[]
#add_attribute
#add_attributes
#add_element
#add_namespace
#add_text
#attribute
#cdatas
#clone
#comments
#delete_attribute
#delete_element
#delete_namespace
#document
#each_element
#each_element_with_attribute
#each_element_with_text
#get_elements
#get_text
#has_attributes?
#has_elements?
#has_text?
#ignore_whitespace_nodes
#inspect
#instructions
#namespace
#namespaces
#next_element
#node_type
#prefixes
#previous_element
#raw
#root
#root_node
#text
#text=
#texts
#whitespace
#write
#xpath






















An element has a name:

  root_ele.name # => "bookstore"

An element may have a parent:

- The parent of a root element is the document:

    root_ele.parent == doc # => true

- The parent of any non-root element is another element, or +nil+:

    first_book_ele = root_ele.elements.first
    parent_ele = first_book_ele.parent
    parent_ele                       # => <bookstore> ... </>
    parent_ele.class                 # => REXML::Element
    REXML::Element.new('foo').parent # => nil

An element may have children.
The children may include any combination of elements, text,
comments, processing instructions, and CDATA.

In our example, the root element has children that are text and elements:

  doc.root.children.each {|child| p [child.class, child] }

Output:

  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='COOKING'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='CHILDREN'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='WEB'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='WEB'> ... </>]
  [REXML::Text, "\n\n    "]

You can retrieve an element's children using inherited method REXML::Parent#children.

  doc.root.children.each_with_index do |child, i|
    next if (2..6).include?(i) # Show only first two and last two.
    p [i, child.class, child]
    p ['  Prev: ', child.previous_sibling]
    p ['  Next: ', child.next_sibling]
  end

Output:

  [0, REXML::Text, "\n\n"]
  ["  Prev: ", nil]
  ["  Next: ", <book category='cooking'> ... </>]
  [1, REXML::Element, <book category='cooking'> ... </>]
  ["  Prev: ", "\n\n"]
  ["  Next: ", "\n\n"]
  [7, REXML::Element, <book category='web' cover='paperback'> ... </>]
  ["  Prev: ", "\n\n"]
  ["  Next: ", "\n\n"]
  [8, REXML::Text, "\n\n"]
  ["  Prev: ", <book category='web' cover='paperback'> ... </>]
  ["  Next: ", nil]

Note that the previous sibling for the first chile is +nil+,
and the next sibling for the last child is +nil+.

An element may have attributes:

  attrs = first_book_ele.attributes
  attrs                  # => {"category"=>category='COOKING'}
  attrs.size             # => 1
  attrs.class            # => REXML::Attributes
  attrs.class.superclass # => Hash

== Exploring Attributes

An REXML::Attribute object represents an XML attribute.

An attribute has a name

== Traversing the Tree

== Searching the Tree

