= \REXML Tutorial

The two classes you're likely to be using most of the time are:

- REXML::Document: represents an XML document.
- REXML::Element: represents an XML element.

This tutorial covers both classes in great detail.

== Preliminaries

All examples here assume that the following code has been executed:

  require 'rexml/document'

The source XML for many examples here is from file
{books.xml}[https://www.w3schools.com/xml/books.xml] at w3schools.com.
You may find it convenient to open that page in a new tab
(Ctrl-click in some browsers).

Note that your browser may display the XML with modified whitespace
and without the XML declaration, which in this case is:

  <?xml version="1.0" encoding="UTF-8"?>

For convenience, we capture the XML into a string variable:

  require 'open-uri'
  source_string = URI.open('https://www.w3schools.com/xml/books.xml').read

And into a file:

  File.write('source_file.xml', source_string)

== Parsing \XML \Source

=== REXML::Document.new

Use method REXML::Document.new to parse XML source.

The source may be a string:

  doc = REXML::Document.new(source_string)

Or an \IO stream:

  doc = File.open('source_file.xml', 'r') do |io|
    REXML::Document.new(io)
  end

Method <tt>URI.open</tt> returns a StringIO object,
so the source can be from a web page:

  require 'open-uri'
  io = URI.open("https://www.w3schools.com/xml/books.xml")
  io.class # => StringIO
  doc = REXML::Document.new(io)

For any of these sources, the returned object is an REXML::Document:

  doc       # => <UNDEFINED> ... </>
  doc.class # => REXML::Document

=== Context (Parsing Options)

The context for parsing a document is a hash that influences
the way the XML is read and stored.

The context entries are:

- +:respect_whitespace+: controls treatment of whitespace.
- +:compress_whitespace+: determines whether whitespace is compressed.
- +:ignore_whitespace_nodes+: determines whether whitespace-only nodes are to be ignored.
- +:raw+: controls treatment of special characters and entities.

See {Element Context}[../context_rdoc.html]

== Exploring the Document

An REXML::Document object represents an XML document.

A document inherits from its ancestor classes:

- REXML::Child (includes module REXML::Node)
  - REXML::Parent (includes module {Enumerable}[rdoc-ref:Enumerable]).
    - REXML::Element (includes module REXML::Namespace).
      - REXML::Document

This section covers only properties and methods unique to a document
(that is, not inherited or included).

[Root Element]

  A document may have a single element child, called the _root_ _element_,
  that may be retrieved with method +root+:

    doc.root # => <bookstore> ... </>
    doc.root.class # => REXML::Element

    REXML::Document.new('').root # => nil

[XML Declaration]

  A document has an XML declaration:

    doc.xml_decl # => <?xml ... ?>
    doc.xml_decl.class # => REXML::XMLDecl

    REXML::Document.new('').xml_decl # => <?xml ... ?>

    other_xml_source = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>"'
    other_doc = REXML::Document.new(other_xml_source)
    xml_decl = other_doc.xml_decl
    xml_decl.to_s  # => "<?xml version='1.0' encoding='UTF-8' standalone="yes"?>"

  The version, encoding, and stand-alone values may be retrieved separately:

    other_doc.version      # => "1.0"
    other_doc.encoding     # => "UTF-8"
    other_doc.stand_alone? # => "yes"

[Document Type]

  A document may have a document type:

    doc.doctype # => nil

    doc_type = REXML::Document.new('<!DOCTYPE foo>').doctype
    doc_type.class # => REXML::DocType
    doc_type.to_s  # => "<!DOCTYPE foo>"
    doc.doc_type   # => nil

[Node Type]

  A document also has a node type (always +:document+):

    doc.node_type # => :document

[Name]

  A document has a name (always an empty string):

    doc.name # => ""

[Document]

  \Method REXML::Document#document returns +self+:

    doc.document == doc # => true

  An object of a different class (\REXML::Element or \REXML::Child)
  may have a document, which is the document to which the object belongs;
  if so, that document will be an \REXML::Document object.

    doc.root.document.class # => REXML::Document

The payload of a document is a tree of nodes, descending from the root element:

  root_ele.children.each do |child|
    p [child, child.class]
  end

Output:

  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='cooking'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='children'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web'> ... </>]
  [REXML::Text, "\n\n"]
  [REXML::Element, <book category='web' cover='paperback'> ... </>]
  [REXML::Text, "\n\n"]

Note that while in this example, all the element children of the root element are
elements of the same name, <tt>'book'</tt>, that is not true of all documents;
a root element (or any other element) may have any mixture of child elements.

Note also that the document is itself an element:

  doc.kind_of?(REXML::Element) # => true

because the parent class of \REXML::Document is \REXML::Element.

== Exploring an Element

An REXML::Element object represents an XML element.

An element inherits from its ancestor classes:

- REXML::Child (includes module REXML::Node)
  - REXML::Parent (includes module {Enumerable}[rdoc-ref:Enumerable]).
    - REXML::Element (includes module REXML::Namespace).

This section covers methods:

- Defined in REXML::Element itself.
- Inherited from REXML::Parent and REXML::Child.
- Included from REXML::Node.

=== Inside the Element

[Brief String Representation]

  Use method REXML::Element#inspect to retrieve a brief string representation.

    doc.root.inspect # => "<bookstore> ... </>"

[Extended String Representation]

  Use inherited method REXML::Child.bytes to retrieve an extended
  string representation.

    doc.root.bytes # => "<bookstore>\n\n<book category='cooking'>\n  <title lang='en'>Everyday Italian</title>\n  <author>Giada De Laurentiis</author>\n  <year>2005</year>\n  <price>30.00</price>\n</book>\n\n<book category='children'>\n  <title lang='en'>Harry Potter</title>\n  <author>J K. Rowling</author>\n  <year>2005</year>\n  <price>29.99</price>\n</book>\n\n<book category='web'>\n  <title lang='en'>XQuery Kick Start</title>\n  <author>James McGovern</author>\n  <author>Per Bothner</author>\n  <author>Kurt Cagle</author>\n  <author>James Linn</author>\n  <author>Vaidyanathan Nagarajan</author>\n  <year>2003</year>\n  <price>49.99</price>\n</book>\n\n<book category='web' cover='paperback'>\n  <title lang='en'>Learning XML</title>\n  <author>Erik T. Ray</author>\n  <year>2003</year>\n  <price>39.95</price>\n</book>\n\n</bookstore>"

[Node Type]

  Use method REXML::Element.node_type to retrieve the node type (always +:element+):

    doc.root.node_type # => :element

[Raw Mode]

  Use method REXML::Element#raw to retrieve whether (+true+ or +nil+)
  raw mode is set.

    doc.root.raw # => nil

[Context]

  Use method REXML::Element.context to retrieve the context hash
  (see {Element Context}[../context_rdoc.html]):

    doc.root.context # => {}

=== Relationships

==== Ancestors

[Containing Document]

  Use method REXML::Element#document to retrieve the containing document, if any:

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.document                    # => <UNDEFINED> ... </>
    ele = REXML::Element.new('foo') # => <foo/>
    ele.document                    # => nil

[Root Element]

  Use method REXML::Element#root to retrieve the root element:

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.root                        # => <bookstore> ... </>
    ele = REXML::Element.new('foo') # => <foo/>
    ele.root                        # => <foo/>

[Root Node]

  Use method REXML::Element#root_node to retrieve the most distant ancestor,
  which is the containing document, if any, otherwise the root element:

    ele = doc.root.elements.first   # => <book category='cooking'> ... </>
    ele.root_node                   # => <UNDEFINED> ... </>
    ele = REXML::Element.new('foo') # => <foo/>
    ele.root_node                   # => <foo/>

[Parent]

  Use inherited method REXML::Child#parent to retrieve the parent

    ele = doc.root                # => <bookstore> ... </>
    ele.parent                    # => <UNDEFINED> ... </>
    ele = doc.root.elements.first # => <book category='cooking'> ... </>
    ele.parent                    # => <bookstore> ... </>

  Use included method REXML::Node#index_in_parent to retrieve the index
  of the element among all of its parents children (not just the element children).
  Note that while the index for <tt>doc.root.elements[n]</tt> is 1-based,
  the returned index is 0-based.

    doc.root.children # =>
      # ["\n\n",
      #  <book category='cooking'> ... </>,
      #  "\n\n",
      #  <book category='children'> ... </>,
      #  "\n\n",
      #  <book category='web'> ... </>,
      #  "\n\n",
      #  <book category='web' cover='paperback'> ... </>,
      #  "\n\n"]
    ele = doc.root.elements[1] # => <book category='cooking'> ... </>
    ele.index_in_parent # => 2
    ele = doc.root.elements[2]  # => <book category='children'> ... </>
    ele.index_in_parent# => 4

==== Siblings

[Next Element]

  Use method REXML::Element.next_element to retrieve the first following
  sibling that is itself an element (+nil+ if there is none):

    ele = doc.root.elements[1]
    while ele do
      p [ele.class, ele]
      ele = ele.next_element
    end
    p ele

  Output:

        p ele
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    nil

[Previous Element]

  Use method REXML::Element.previous_element to retrieve the first preceding
  sibling that is itself an element (+nil+ if there is none):

    ele = doc.root.elements[4]
    while ele do
      p [ele.class, ele]
      ele = ele.previous_element
    end
    p ele

  Output:

    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Element, <book category='cooking'> ... </>]
    nil

[Next Node]

  Use included method REXML::Node.next_sibling_node
  (or its alias <tt>next_sibling</tt>) to retrieve the first following node
  regardless of its class:

    node = doc.root.children[0]
    while node do
      p [node.class, node]
      node = node.next_sibling
    end
    p node

  Output:

    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Text, "\n\n"]
    nil

[Previous Node]

  Use included method REXML::Node.previous_sibling_node
  (or its alias <tt>previous_sibling</tt>) to retrieve the first preceding node
  regardless of its class:

    node = doc.root.children[-1]
    while node do
      p [node.class, node]
      node = node.previous_sibling
    end
    p node

  Output:

    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web' cover='paperback'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='web'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='children'> ... </>]
    [REXML::Text, "\n\n"]
    [REXML::Element, <book category='cooking'> ... </>]
    [REXML::Text, "\n\n"]
    nil

==== Children

[Size]

  Use inherited method REXML::Parent.size to retrieve the count
  of nodes (of all types) in the element:

    doc.root.size # => 9

[Children]

  Use inherited method REXML::Parent.children to retrieve an array
  of the child nodes (of all types):

    doc.root.children # =>
                      # ["\n\n",
                      #  <book category='cooking'> ... </>,
                      #  "\n\n",
                      #  <book category='children'> ... </>,
                      #  "\n\n",
                      #  <book category='web'> ... </>,
                      #  "\n\n",
                      #  <book category='web' cover='paperback'> ... </>,
                      #  "\n\n"]

[Child at Index]

  Use method REXML::Element.[] to retrieve the child at a given numerical index,
  or +nil+ if there is no such child:

    doc.root[0]  # => "\n\n"
    doc.root[1]  # => <book category='cooking'> ... </>
    doc.root[7]  # => <book category='web' cover='paperback'> ... </>
    doc.root[8]  # => "\n\n"

    doc.root[-1] # => "\n\n"
    doc.root[-2] # => <book category='web' cover='paperback'> ... </>

    doc.root[50] # => nil

[Index of Child]

  Use method REXML::Element.index to retrieve the zero-based child index
  of the given object, or <tt>#size - 1</tt> if there is no such child:

    ele = doc.root     # => <bookstore> ... </>
    ele.index(ele[0])  # => 0
    ele.index(ele[1])  # => 1
    ele.index(ele[7])  # => 7
    ele.index(ele[8])  # => 8

    ele.index(ele[-1]) # => 8
    ele.index(ele[-2]) # => 7

    ele.index(ele[50]) # => 8

[Element Children]

  Use method REXML::.has_elements? to retrieve whether the element
  has element children:

    doc.root.has_elements?                  # => true
    REXML::Element.new('foo').has_elements? # => false

  Use method REXML::Element.elements to retrieve the REXML::Elements object
  containing the element children:

    eles = doc.root.elements
    eles      # => #<REXML::Elements:0x000001ee2848e960 @element=<bookstore> ... </>>
    eles.size # => 4

[CDATA Children]

  Use method REXML::Element.cdatas to retrieve a frozen array of CDATA children:

    xml_string = <<-EOT
      <root>
        <![CDATA[foo]]>
        <![CDATA[bar]]>
      </root>
    EOT
    d = REXML::Document.new(xml_string)
    cds = d.root.cdatas      # => ["foo", "bar"]
    cds.frozen?              # => true
    cds.map {|cd| cd.class } # => [REXML::CData, REXML::CData]

[Comment Children]

  Use method REXML::Element.comments to retrieve a frozen array of comment children:

    xml_string = <<-EOT
      <root>
        <!--foo-->
        <!--bar-->
      </root>
    EOT
    d = REXML::Document.new(xml_string)
    cs = d.root.comments
    cs.frozen?            # => true
    cs.map {|c| c.class } # => [REXML::Comment, REXML::Comment]
    cs.map {|c| c.to_s }  # => ["foo", "bar"]

[Processing Instruction Children]

  Use method REXML::Element.instructions to retrieve a frozen array
  of processing instruction children:

    xml_string = <<-EOT
      <root>
        <?target0 foo?>
        <?target1 bar?>
      </root>
    EOT
    d = REXML::Document.new(xml_string)
    instrs = d.root.instructions
    instrs.frozen?            # => true
    instrs.map {|i| i.class } # => [REXML::Instruction, REXML::Instruction]
    instrs.map {|i| i.to_s }  # => ["<?target0 foo?>", "<?target1 bar?>"]

[Text Children]

  Use method REXML::Element.has_text? to retrieve whether the element
  has text children:

    doc.root.has_text?                  # => true
    REXML::Element.new('foo').has_text? # => false

  Use method REXML::Element.texts to retrieve a frozen array of text children:

    xml_string = '<root><a/>text<b/>more<c/></root>'
    d = REXML::Document.new(xml_string)
    ts = d.root.texts
    ts.frozen?            # => true
    ts.map {|t| t.class } # => [REXML::Text, REXML::Text]
    ts.map {|t| t.to_s }  # => ["text", "more"]

[Parenthood]

  Use inherited method REXML::Parent.parent? to retrieve whether the element is a parent;
  always returns +true+; only REXML::Child#parent returns +false+.

     doc.root.parent? # => true

== Attributes

  #[]
  #attribute
  #attributes
  #has_attributes?

== Whitespace

  #ignore_whitespace_nodes?
  #whitespace

== Namespaces

  #namespace
  #namespaces
  #prefixes

== Searching

  #text
  #xpath
  #get_elements
  #get_text
  #find_first_recursive

- Traversing

  #each_element_with_attribute
  #each_element
  #each_element_with_text
  #each_child
  #each_index























An element has a name:

  root_ele.name # => "bookstore"

An element may have a parent:

- The parent of a root element is the document:

    root_ele.parent == doc # => true

- The parent of any non-root element is another element, or +nil+:

    first_book_ele = root_ele.elements.first
    parent_ele = first_book_ele.parent
    parent_ele                       # => <bookstore> ... </>
    parent_ele.class                 # => REXML::Element
    REXML::Element.new('foo').parent # => nil

An element may have children.
The children may include any combination of elements, text,
comments, processing instructions, and CDATA.

In our example, the root element has children that are text and elements:

  doc.root.children.each {|child| p [child.class, child] }

Output:

  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='COOKING'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='CHILDREN'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='WEB'> ... </>]
  [REXML::Text, "\n\n    "]
  [REXML::Element, <book category='WEB'> ... </>]
  [REXML::Text, "\n\n    "]

You can retrieve an element's children using inherited method REXML::Parent#children.

  doc.root.children.each_with_index do |child, i|
    next if (2..6).include?(i) # Show only first two and last two.
    p [i, child.class, child]
    p ['  Prev: ', child.previous_sibling]
    p ['  Next: ', child.next_sibling]
  end

Output:

  [0, REXML::Text, "\n\n"]
  ["  Prev: ", nil]
  ["  Next: ", <book category='cooking'> ... </>]
  [1, REXML::Element, <book category='cooking'> ... </>]
  ["  Prev: ", "\n\n"]
  ["  Next: ", "\n\n"]
  [7, REXML::Element, <book category='web' cover='paperback'> ... </>]
  ["  Prev: ", "\n\n"]
  ["  Next: ", "\n\n"]
  [8, REXML::Text, "\n\n"]
  ["  Prev: ", <book category='web' cover='paperback'> ... </>]
  ["  Next: ", nil]

Note that the previous sibling for the first chile is +nil+,
and the next sibling for the last child is +nil+.

An element may have attributes:

  attrs = first_book_ele.attributes
  attrs                  # => {"category"=>category='COOKING'}
  attrs.size             # => 1
  attrs.class            # => REXML::Attributes
  attrs.class.superclass # => Hash

== Exploring Attributes

An REXML::Attribute object represents an XML attribute.

An attribute has a name

== Traversing the Tree

== Searching the Tree

