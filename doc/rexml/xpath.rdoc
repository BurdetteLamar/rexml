== XPaths in \REXML

This page describes \REXML's handling of XPath.

The source XML for many examples here is from file
{books.xml}[https://www.w3schools.com/xml/books.xml] at w3schools.com.
You may find it convenient to open that page in a new tab
(Ctrl-click in some browsers).

Many examples here use the variables +doc+ and +root_ele+ resulting from:

  require 'rexml/document'
  require 'open-uri'
  url = 'https://www.w3schools.com/xml/books.xml'
  doc = REXML::Document.new(URI.open(url).read)
  root_ele = doc.root

The examples here use method

  ary = REXML::XPath.match(node, path)

where:

- +node+ is the node where the search begins.
- +path+ is the path that controls the search.
- +ary+ is the returned array of nodes (possibly empty).

=== Generic Paths

A few paths are generic -- that is, they do not refer directly
to any specific element in the document.

- Path <tt>'/'</tt> selects only the document containing the given node,
  or if the node is not in a document, selects only the node itself:

    ary = REXML::XPath.match(doc, '/')
    ary.class       # => Array
    ary             # => [<UNDEFINED> ... </>]
    ary.first.class # => REXML::Document
    ary = REXML::XPath.match(doc.root, '/')
    ary             # => [<UNDEFINED> ... </>]
    ary.first.class # => REXML::Document
    ary = REXML::XPath.match(doc.root.elements.first, '/')
    ary             # => [<UNDEFINED> ... </>]
    ary.first.class # => REXML::Document
    ary = REXML::XPath.match(REXML::Element.new('foo'), '/')
    ary             # => [<foo/>]
    ary.first.class # => REXML::Element

- Path <tt>'..'</tt> selects only the parent of the given node, if it exists:

    path = '..'
    ary = REXML::XPath.match(doc, path)
    ary # => []
    ary = REXML::XPath.match(doc.root, path)
    ary       # => [<UNDEFINED> ... </>] # doc
    ary = REXML::XPath.match(doc.root.elements.first, path)
    ary       # => [<bookstore> ... </>]
    ary = REXML::XPath.match(REXML::Element.new('foo'), path)
    ary       # => []

- Trivially, path <tt>'.'</tt> selects only the given node:

    path = '.'
    ary = REXML::XPath.match(doc, path)
    ary.class # => [<UNDEFINED> ... </>] # doc
    ary = REXML::XPath.match(doc.root, path)
    ary       # => [<bookstore> ... </>]
    ary = REXML::XPath.match(REXML::Element.new('foo'), path)
    ary       # => [<foo/>]

=== Absolute Paths

A path beginning with a single slash <tt>'/'</tt> is an _absolute_ _path_.
An absolute path must begin with the rootname (else no nodes are returned).

Path <tt>'/rootname'</tt> selects the root element if it has that name:

  ary = REXML::XPath.match(doc, '/bookstore')
  ary             # => [<bookstore> ... </>]
  ary = REXML::XPath.match(doc, '/book')
  ary             # => []

Path <tt>'/rootname/childname'</tt> selects all children of the root element
that have the given +childname+:

  ary = REXML::XPath.match(doc, '/bookstore/book')
  ary # =>  [<book category='cooking'> ... </>,
      #      <book category='children'> ... </>,
      #      <book category='web'> ... </>,
      #      <book category='web' cover='paperback'> ... </>]

A longer absolute path:

  ary = REXML::XPath.matc

Select all +book+ elements that are children of +bookstore+:

  ary = REXML::XPath.match(doc, 'bookstore/book')
  ary # =>
        # [<book category='cooking'> ... </>,
        #  <book category='children'> ... </>,
        #  <book category='web'> ... </>,
        #  <book category='web' cover='paperback'> ... </>]

Select all +book+ elements no matter where they are in the document:

  ary = REXML::XPath.match(doc, '//book')
  ary # =>
        # [<book category='cooking'> ... </>,
        #  <book category='children'> ... </>,
        #  <book category='web'> ... </>,
        #  <book category='web' cover='paperback'> ... </>]

Select all +book+ elements that are descendants of +bookstore+ element,
no matter where they are in the document:

  ary = REXML::XPath.match(doc, 'bookstore//book')
  ary # =>
       # [<book category='cooking'> ... </>,
       #  <book category='children'> ... </>,
       #  <book category='web'> ... </>,
       #  <book category='web' cover='paperback'> ... </>]

Select all attributes named +lang+:

  attrs = REXML::XPath.match(doc, '//@lang')
  attrs             # => [lang='en', lang='en', lang='en', lang='en']
  attrs.first.class # => REXML::Attribute

Select the first +book+ element that is the child of element +bookstore+:

  ary = REXML::XPath.match(doc, '/bookstore/book[1]')
  ary # => [<book category='cooking'> ... </>]

=== Relative Paths

===